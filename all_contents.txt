File: ./src/dirtty/themes.py
import yaml
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_themes():
    themes_dir = Path(__file__).parent.parent / "themes"
    logger.debug(f"Loading themes from {themes_dir}")
    themes = {}
    theme_files = list(themes_dir.glob('*.yaml'))
    logger.debug(f"Found theme files: {theme_files}")
    for theme_file in theme_files:
        try:
            with open(theme_file, "r") as f:
                theme_data = yaml.safe_load(f)
                themes[theme_data["name"]] = theme_data
                logger.debug(f"Loaded theme: {theme_data['name']}")
        except Exception as e:
            logger.error(f"Error loading theme from {theme_file}: {str(e)}")

    if "default" not in themes:
        logger.error("Default theme not found. Creating a basic default theme.")
        themes["default"] = create_default_theme()

    return themes

def create_default_theme():
    return {
        "name": "default",
        "dark": False,
        "colors": {
            "primary": "#004578",
            "secondary": "#393939",
            "background": "#FFFFFF",
            "surface": "#EEEEEE",
            "panel": "#F0F0F0",
            "boost": "rgba(0, 0, 0, 0.1)",
            "success": "#2EA043",
            "warning": "#D29922",
            "error": "#DA3633",
            "accent": "#0366D6",
            "text": "#000000"
        }
    }

THEMES = load_themes()

def get_theme(theme_name):
    logger.debug(f"Getting theme: {theme_name}")
    theme = THEMES.get(theme_name)
    if theme is None:
        logger.warning(f"Theme '{theme_name}' not found. Using default theme.")
        theme = THEMES["default"]
    return theme


File: ./src/dirtty/config.py
import yaml
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_config(config_path: Path = Path("config.yaml")):
    logger.info(f"Attempting to load config from {config_path}")
    try:
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
            logger.info(f"Config loaded successfully: {config}")
            return config
    except FileNotFoundError:
        logger.warning(f"Config file {config_path} not found. Using default configuration.")
        return {}

def save_config(config: dict, config_path: Path = Path("config.yaml")):
    logger.info(f"Saving config to {config_path}")
    with open(config_path, "w") as f:
        yaml.dump(config, f)
    logger.info("Config saved successfully")


File: ./src/dirtty/__init__.py



File: ./src/dirtty/cli.py
import argparse
import logging
from dirtty.config import load_config, save_config

logger = logging.getLogger(__name__)

def parse_args():
    logger.info("Parsing command line arguments")
    parser = argparse.ArgumentParser(description="dirtty - LlamaIndex Chatbot")
    parser.add_argument("--directory", type=str, default=None,
                        help="Directory containing documents to index")
    parser.add_argument("--model-name", type=str, default="llama3:latest",
                        help="Name of the Ollama model to use")
    parser.add_argument("--theme", type=str, default="default",
                        help="Name of the theme to use")
    parser.add_argument("-v", "--verbose", action="count",
                        default=0, help="Increase verbosity level")
    args = parser.parse_args()
    logger.debug(f"Parsed arguments: {args}")

    config = load_config()
    logger.debug(f"Loaded config: {config}")

    config['model_name'] = args.model_name or config.get('model_name', 'llama3:latest')
    config['theme'] = args.theme or config.get('theme', 'default')

    if args.verbose == 1:
        config['log_level'] = 'INFO'
    elif args.verbose >= 2:
        config['log_level'] = 'DEBUG'
    else:
        config['log_level'] = config.get('log_level', 'WARNING')

    logger.info(f"Final config: {config}")
    save_config(config)

    config['args'] = args

    return config


File: ./src/dirtty/app.py
from textual.app import App, ComposeResult
from textual.containers import Container, Vertical, Horizontal
from textual.widgets import Header, Footer, DirectoryTree, Input, RichLog, Button
from textual.reactive import reactive
from textual.screen import Screen
from rich.text import Text
from pathlib import Path
from llama_index.core.query_engine import BaseQueryEngine
from llama_index.core import VectorStoreIndex, Settings
from llama_index.llms.ollama import Ollama
from llama_index.embeddings.huggingface import HuggingFaceEmbedding
from llama_index.core.memory import ChatMemoryBuffer
from llama_index.core import SimpleDirectoryReader
import logging
from dirtty.themes import get_theme

logger = logging.getLogger(__name__)

class DirectorySelector(Screen):
    def compose(self) -> ComposeResult:
        yield Container(
            Vertical(
                DirectoryTree("/"),
                Button("Select Directory", variant="primary", id="select_dir"),
                id="dir_selector"
            )
        )

    def on_button_pressed(self, event: Button.Pressed) -> None:
        if event.button.id == "select_dir":
            selected_node = self.query_one(DirectoryTree).cursor_node
            if selected_node and selected_node.data.is_dir():
                self.app.selected_directory = Path(selected_node.data.path)
                self.app.pop_screen()

class DirttyApp(App):
    BINDINGS = [("d", "toggle_dark", "Toggle dark mode")]

    CSS = """
    Screen {
        background: $background;
        color: $text;
    }

    #dir_selector {
        width: 60%;
        height: 60%;
        border: heavy $primary;
        padding: 1 2;
    }

    #main-content {
        width: 100%;
        height: 100%;
    }

    #sidebar {
        width: 25%;
        height: 100%;
        background: $surface;
    }

    #chat-area {
        width: 75%;
        height: 100%;
    }

    #chat-messages {
        height: 85%;
        width: 100%;
        overflow-y: auto;
    }

    #chat-input {
        height: 15%;
        width: 100%;
        dock: bottom;
        background: $surface;
        color: $text;
    }

    Button {
        background: $primary;
        color: $background;
    }

    Button:hover {
        background: $accent;
    }
    """

    selected_directory = reactive(Path)

    def __init__(self, directory: Path | None = None, model_name: str = "llama3:latest", theme: str = "default"):
        super().__init__()
        self.selected_directory = directory if directory else Path()
        self.query_engine = None
        self.model_name = model_name
        self.theme_name = theme

    def compose(self) -> ComposeResult:
        yield Header()
        with Horizontal(id="main-content"):
            yield Container(DirectoryTree(str(self.selected_directory)), id="sidebar")
            with Container(id="chat-area"):
                yield RichLog(id="chat-messages", wrap=True)
                yield Input(placeholder="Type your message here...", id="chat-input")
        yield Footer()

    def on_directory_selector_screen_pop(self) -> None:
        self.setup_chat_interface()

    def apply_theme(self):
        theme_data = get_theme(self.theme_name)
        logger.debug(f"Applying theme: {theme_data}")

        colors = theme_data.get("colors", {})

        css = self.CSS
        for color_name, color_value in colors.items():
            css = css.replace(f"${color_name}", color_value)

        self.screen.styles.background = colors.get("background", "#FFFFFF")
        self.screen.styles.color = colors.get("text", "#000000")

        self.dark = theme_data.get("dark", False)
        self.CSS = css
        logger.info(f"Applied theme: {self.theme_name}")

    def on_mount(self) -> None:
        self.apply_theme()
        if not self.selected_directory or not self.selected_directory.exists():
            self.push_screen(DirectorySelector())
        else:
            self.setup_chat_interface()

    def setup_chat_interface(self) -> None:
        self.title = f"Dirtty - Chatting about {self.selected_directory.name}"
        self.query_one("#chat-input").focus()
        if not self.query_engine:
            self.initialize_query_engine()

    def initialize_query_engine(self) -> None:
        documents = self.load_documents()
        llm = self.setup_llm()
        index = self.setup_index(documents, llm)
        self.query_engine = self.create_query_engine(index)

    def load_documents(self):
        logger.info(f"Loading documents from {self.selected_directory}")
        documents = SimpleDirectoryReader(input_dir=str(self.selected_directory), recursive=True).load_data()
        logger.info(f"Loaded {len(documents)} documents")
        return documents

    def setup_llm(self):
        logger.info(f"Setting up Ollama LLM with model: {self.model_name}")
        from ollama import Client
        client = Client()
        try:
            client.show(self.model_name)
        except Exception as error:
            logger.error(f"Model '{self.model_name}' not found. Error: {str(error)}")
            raise ValueError(f"Model '{self.model_name}' not found. Please pull it using 'ollama pull {self.model_name}' before running the application.")
        return Ollama(model=self.model_name, request_timeout=360.0)

    def setup_index(self, documents, llm):
        logger.info("Setting up index")
        Settings.embed_model = HuggingFaceEmbedding(model_name="BAAI/bge-base-en-v1.5")
        Settings.llm = llm
        index = VectorStoreIndex.from_documents(documents, show_progress=False)
        logger.info("Index setup complete")
        return index

    def create_query_engine(self, index):
        logger.info("Creating query engine")
        memory = ChatMemoryBuffer.from_defaults(token_limit=300000)
        chat_engine = index.as_chat_engine(
            chat_mode="context",
            memory=memory,
            system_prompt="You are a chat bot able to have normal interactions and to provide coding support, as well as talk about the contents of a directory. Keep your responses concise and to the point.",
            max_iterations=10,
        )
        logger.info("Query engine created")
        return chat_engine

    def on_input_submitted(self, event: Input.Submitted) -> None:
        if not self.query_engine:
            self.query_one("#chat-messages", RichLog).write(Text("Error: Query engine not initialized", style="bold red"))
            return

        input_widget = event.input
        message = input_widget.value
        self.query_one("#chat-messages", RichLog).write(f"You: {message}")

        try:
            response = self.query_engine.chat(message)
            self.query_one("#chat-messages", RichLog).write(f"Assistant: {str(response)}")
        except Exception as error:
            self.query_one("#chat-messages", RichLog).write(Text(f"Error: {str(error)}", style="bold red"))

        input_widget.value = ""
        self.query_one("#chat-messages").scroll_end(animate=False)

    def action_toggle_dark(self) -> None:
        """An action to toggle dark mode."""
        self.dark = not self.dark


File: ./src/dirtty/main.py
import logging
import sys
from pathlib import Path
from dirtty.cli import parse_args
from dirtty.helpers import setup_logging, clear_screen
from dirtty.app import DirttyApp

logger = logging.getLogger(__name__)

def main():
    opts = parse_args()

    setup_logging(opts['log_level'])

    logger.debug(f"Parsed options: {opts}")

    logger.info("Starting dirtty application")

    directory = Path(opts['args'].directory) if opts['args'].directory else None

    clear_screen()

    try:
        app = DirttyApp(directory, opts['model_name'], opts['theme'])
        app.run()
    except ValueError as error:
        logger.error(str(error))
        print(f"Error: {str(error)}")
        sys.exit(1)

if __name__ == "__main__":
    main()


File: ./src/dirtty/helpers.py
import os
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

def setup_logging(log_level: str) -> None:
    if isinstance(log_level, int):
        log_level = logging.getLevelName(log_level)

    log_level = log_level.upper()
    numeric_level = getattr(logging, log_level, None)
    if not isinstance(numeric_level, int):
        raise ValueError(f'Invalid log level: {log_level}')

    log_dir = Path.home() / ".dirtty" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / "dirtty.log"

    logging.basicConfig(
        filename=str(log_file),
        level=numeric_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger.info(f"Logging setup complete. Log level: {log_level}")
    logger.info(f"Log file location: {log_file}")

def ensure_directory(directory: str) -> Path:
    path = Path(directory)
    path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Ensured directory exists: {path}")
    return path

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')


File: ./src/dirtty/themes.py
import yaml
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_themes():
    themes_dir = Path(__file__).parent.parent / "themes"
    logger.debug(f"Loading themes from {themes_dir}")
    themes = {}
    theme_files = list(themes_dir.glob('*.yaml'))
    logger.debug(f"Found theme files: {theme_files}")
    for theme_file in theme_files:
        try:
            with open(theme_file, "r") as f:
                theme_data = yaml.safe_load(f)
                themes[theme_data["name"]] = theme_data
                logger.debug(f"Loaded theme: {theme_data['name']}")
        except Exception as e:
            logger.error(f"Error loading theme from {theme_file}: {str(e)}")

    if "default" not in themes:
        logger.warning("Default theme not found. Creating a basic default theme.")
        themes["default"] = create_default_theme()
    return themes


def create_default_theme():
    return {
        "name": "default",
        "dark": False,
        "colors": {
            "primary": "#004578",
            "secondary": "#393939",
            "background": "#FFFFFF",
            "surface": "#EEEEEE",
            "panel": "#F0F0F0",
            "boost": "rgba(0, 0, 0, 0.1)",
            "success": "#2EA043",
            "warning": "#D29922",
            "error": "#DA3633",
            "accent": "#0366D6",
            "text": "#000000"
        }
    }

THEMES = load_themes()

def get_theme(theme_name):
    logger.debug(f"Getting theme: {theme_name}")
    theme = THEMES.get(theme_name)
    if theme is None:
        logger.warning(f"Theme '{theme_name}' not found. Using default theme.")
        theme = THEMES["default"]
    return theme


File: ./src/dirtty/config.py
import yaml
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_config(config_path: Path = Path("config.yaml")):
    logger.info(f"Attempting to load config from {config_path}")
    try:
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
            logger.info(f"Config loaded successfully: {config}")
            return config
    except FileNotFoundError:
        logger.warning(f"Config file {config_path} not found. Using default configuration.")
        return {}

def save_config(config: dict, config_path: Path = Path("config.yaml")):
    logger.info(f"Saving config to {config_path}")
    with open(config_path, "w") as f:
        yaml.dump(config, f)
    logger.info("Config saved successfully")


File: ./src/dirtty/directory_selector.py
from textual.app import App, ComposeResult
from textual.widgets import DirectoryTree, Footer

class DirectorySelector(App):
    def compose(self) -> ComposeResult:
        yield DirectoryTree("/")
        yield Footer()

    def on_directory_tree_file_selected(self, event: DirectoryTree.DirectorySelected) -> None:
        self.selected_directory = event.path
        self.exit(self.selected_directory)


File: ./src/dirtty/__init__.py



File: ./src/dirtty/cli.py
import argparse
import logging
from dirtty.config import load_config, save_config

logger = logging.getLogger(__name__)

def parse_args():
    logger.info("Parsing command line arguments")
    parser = argparse.ArgumentParser(description="dirtty - LlamaIndex Chatbot")
    parser.add_argument("--directory", type=str, default=None,
                        help="Directory containing documents to index")
    parser.add_argument("--model-name", type=str, default="llama3:latest",
                        help="Name of the Ollama model to use")
    parser.add_argument("--theme", type=str, default="default",
                        help="Name of the theme to use")
    parser.add_argument("-v", "--verbose", action="count",
                        default=0, help="Increase verbosity level")
    args = parser.parse_args()
    logger.debug(f"Parsed arguments: {args}")

    config = load_config()
    logger.debug(f"Loaded config: {config}")

    config['model_name'] = args.model_name or config.get('model_name', 'llama3:latest')
    config['theme'] = args.theme or config.get('theme', 'default')

    if args.verbose == 1:
        config['log_level'] = 'INFO'
    elif args.verbose >= 2:
        config['log_level'] = 'DEBUG'
    else:
        config['log_level'] = config.get('log_level', 'WARNING')

    logger.info(f"Final config: {config}")
    save_config(config)

    config['args'] = args

    return config


File: ./src/dirtty/app.py
from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal
from textual.widgets import Header, Footer, DirectoryTree, Input, RichLog
from textual.reactive import reactive
from pathlib import Path
from llama_index.core.query_engine import BaseQueryEngine
from dirtty.themes import get_theme
import logging

logger = logging.getLogger(__name__)

class DirttyApp(App):
    CSS = """
    Screen {
        background: $background;
        color: $text;
    }

    #sidebar {
        width: 25%;
        height: 100%;
        background: $surface;
    }

    #chat-area {
        width: 75%;
        height: 100%;
    }

    #chat-messages {
        height: 85%;
        width: 100%;
        overflow-y: auto;
    }

    #chat-input {
        height: 15%;
        width: 100%;
        dock: bottom;
        background: $surface;
        color: $text;
    }
    """

    selected_directory = reactive(Path)

    def __init__(self, directory: Path, query_engine: BaseQueryEngine, theme: str = "default"):
        super().__init__()
        self.selected_directory = directory
        self.query_engine = query_engine
        self.theme_name = theme

    def compose(self) -> ComposeResult:
        yield Header()
        with Horizontal():
            yield Container(DirectoryTree(str(self.selected_directory)), id="sidebar")
            with Container(id="chat-area"):
                yield RichLog(id="chat-messages", wrap=True)
                yield Input(placeholder="Type your message here...", id="chat-input")
        yield Footer()

    def on_mount(self) -> None:
        self.apply_theme()
        self.title = f"Dirtty - Chatting about {self.selected_directory.name}"
        self.query_one("#chat-input").focus()

    def apply_theme(self):
        theme_data = get_theme(self.theme_name)
        logger.debug(f"Applying theme: {theme_data}")
        colors = theme_data.get("colors", {})
        for color_name, color_value in colors.items():
            self.styles.set(f"${color_name}", color_value)
        self.dark = theme_data.get("dark", False)
        logger.info(f"Applied theme: {self.theme_name}")

    def on_input_submitted(self, event: Input.Submitted) -> None:
        input_widget = event.input
        message = input_widget.value
        self.query_one("#chat-messages", RichLog).write(f"You: {message}")

        try:
            response = self.query_engine.chat(message)
            self.query_one("#chat-messages", RichLog).write(f"Assistant: {str(response)}")
        except Exception as error:
            self.query_one("#chat-messages", RichLog).write(f"Error: {str(error)}", style="bold red")

        input_widget.value = ""
        self.query_one("#chat-messages").scroll_end(animate=False)


File: ./src/dirtty/main.py
import logging
import sys
from pathlib import Path
from dirtty.cli import parse_args
from dirtty.helpers import setup_logging, clear_screen
from dirtty.app import DirttyApp
from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings
from llama_index.llms.ollama import Ollama
from llama_index.embeddings.huggingface import HuggingFaceEmbedding
from llama_index.core.memory import ChatMemoryBuffer
import multiprocessing
from dirtty.directory_selector import DirectorySelector

# Disable tqdm globally
from functools import partialmethod
from tqdm import tqdm
tqdm.__init__ = partialmethod(tqdm.__init__, disable=True)

logger = logging.getLogger(__name__)


def setup_index(documents, llm):
    logger.info("Setting up index")
    Settings.embed_model = HuggingFaceEmbedding(
        model_name="BAAI/bge-base-en-v1.5")
    Settings.llm = llm
    index = VectorStoreIndex.from_documents(documents, show_progress=False)
    logger.info("Index setup complete")
    return index


def load_documents(directory: Path):
    logger.info(f"Loading documents from {directory}")
    documents = SimpleDirectoryReader(
        input_dir=str(directory), recursive=True).load_data()
    logger.info(f"Loaded {len(documents)} documents")
    return documents


def setup_llm(model_name: str):
    logger.info(f"Setting up Ollama LLM with model: {model_name}")
    from ollama import Client
    client = Client()
    try:
        client.show(model_name)
    except Exception as error:
        logger.error(f"Model '{model_name}' not found. Error: {str(error)}")
        raise ValueError(f"Model '{model_name}' not found. Please pull it using 'ollama pull {
                         model_name}' before running the application.")
    return Ollama(model=model_name, request_timeout=360.0)


def create_query_engine(index):
    logger.info("Creating query engine")
    memory = ChatMemoryBuffer.from_defaults(token_limit=300000)
    chat_engine = index.as_chat_engine(
        chat_mode="context",
        memory=memory,
        system_prompt="You are a chat bot able to have normal interactions and to provide coding support, as well as talk about the contents of a directory. Keep your responses concise and to the point.",
        max_iterations=10,
    )
    logger.info("Query engine created")
    return chat_engine


def main():
    # This is required on macOS to avoid issues with multiprocessing
    multiprocessing.set_start_method('spawn', force=True)

    opts = parse_args()
    setup_logging(opts['log_level'])
    logger.debug(f"Parsed options: {opts}")
    logger.info("Starting dirtty application")

    directory = Path(
        opts['args'].directory) if opts['args'].directory else None
    clear_screen()

    if directory is None:
        # Show directory selection screen
        app = DirectorySelector()
        selected_directory = app.run()
        if selected_directory is None:
            logger.error("No directory selected. Exiting.")
            sys.exit(1)
        directory = Path(selected_directory)

    try:
        documents = load_documents(directory)
        llm = setup_llm(opts['model_name'])
        index = setup_index(documents, llm)
        query_engine = create_query_engine(index)

        logger.info("Starting TUI")
        app = DirttyApp(directory, query_engine, opts['theme'])
        app.run()
    except ValueError as error:
        logger.error(str(error))
        print(f"Error: {str(error)}")
        sys.exit(1)


if __name__ == "__main__":
    main()



File: ./src/dirtty/helpers.py
import os
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

def setup_logging(log_level: str) -> None:
    if isinstance(log_level, int):
        log_level = logging.getLevelName(log_level)

    log_level = log_level.upper()
    numeric_level = getattr(logging, log_level, None)
    if not isinstance(numeric_level, int):
        raise ValueError(f'Invalid log level: {log_level}')

    log_dir = Path.home() / ".dirtty" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / "dirtty.log"

    logging.basicConfig(
        filename=str(log_file),
        level=numeric_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger.info(f"Logging setup complete. Log level: {log_level}")
    logger.info(f"Log file location: {log_file}")

def ensure_directory(directory: str) -> Path:
    path = Path(directory)
    path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Ensured directory exists: {path}")
    return path

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')


