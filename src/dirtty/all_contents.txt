File: ./themes.py
import yaml
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_themes():
    themes_dir = Path(__file__).parent.parent / "themes"
    logger.debug(f"Loading themes from {themes_dir}")
    themes = {}
    theme_files = list(themes_dir.glob('*.yaml'))
    logger.debug(f"Found theme files: {theme_files}")
    for theme_file in theme_files:
        try:
            with open(theme_file, "r") as f:
                theme_data = yaml.safe_load(f)
                themes[theme_data["name"]] = theme_data
                logger.debug(f"Loaded theme: {theme_data['name']}")
        except Exception as e:
            logger.error(f"Error loading theme from {theme_file}: {str(e)}")

    if "default" not in themes:
        logger.error("Default theme not found. Creating a basic default theme.")
        themes["default"] = create_default_theme()

    return themes

def create_default_theme():
    return {
        "name": "default",
        "dark": False,
        "colors": {
            "primary": "#004578",
            "secondary": "#393939",
            "background": "#FFFFFF",
            "surface": "#EEEEEE",
            "panel": "#F0F0F0",
            "boost": "rgba(0, 0, 0, 0.1)",
            "success": "#2EA043",
            "warning": "#D29922",
            "error": "#DA3633",
            "accent": "#0366D6",
            "text": "#000000"
        }
    }

THEMES = load_themes()

def get_theme(theme_name):
    logger.debug(f"Getting theme: {theme_name}")
    theme = THEMES.get(theme_name)
    if theme is None:
        logger.warning(f"Theme '{theme_name}' not found. Using default theme.")
        theme = THEMES["default"]
    return theme


File: ./config.py
import yaml
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

def load_config(config_path: Path = Path("config.yaml")):
    logger.info(f"Attempting to load config from {config_path}")
    try:
        with open(config_path, "r") as f:
            config = yaml.safe_load(f)
            logger.info(f"Config loaded successfully: {config}")
            return config
    except FileNotFoundError:
        logger.warning(f"Config file {config_path} not found. Using default configuration.")
        return {}

def save_config(config: dict, config_path: Path = Path("config.yaml")):
    logger.info(f"Saving config to {config_path}")
    with open(config_path, "w") as f:
        yaml.dump(config, f)
    logger.info("Config saved successfully")


File: ./__init__.py



File: ./cli.py
import argparse
import logging
from dirtty.config import load_config, save_config

logger = logging.getLogger(__name__)

def parse_args():
    logger.info("Parsing command line arguments")
    parser = argparse.ArgumentParser(description="dirtty - LlamaIndex Chatbot")
    parser.add_argument("--directory", type=str, default=None,
                        help="Directory containing documents to index")
    parser.add_argument("--model-name", type=str, default="llama3:latest",
                        help="Name of the Ollama model to use")
    parser.add_argument("--theme", type=str, default="default",
                        help="Name of the theme to use")
    parser.add_argument("-v", "--verbose", action="count",
                        default=0, help="Increase verbosity level")
    args = parser.parse_args()
    logger.debug(f"Parsed arguments: {args}")

    config = load_config()
    logger.debug(f"Loaded config: {config}")

    config['model_name'] = args.model_name or config.get('model_name', 'llama3:latest')
    config['theme'] = args.theme or config.get('theme', 'default')

    if args.verbose == 1:
        config['log_level'] = 'INFO'
    elif args.verbose >= 2:
        config['log_level'] = 'DEBUG'
    else:
        config['log_level'] = config.get('log_level', 'WARNING')

    logger.info(f"Final config: {config}")
    save_config(config)

    config['args'] = args

    return config


File: ./app.py
from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal
from textual.widgets import Header, Footer, DirectoryTree, Input, RichLog
from textual.reactive import reactive
from pathlib import Path
from llama_index.core.query_engine import BaseQueryEngine
from dirtty.themes import get_theme
import logging

logger = logging.getLogger(__name__)

class DirttyApp(App):
    CSS = """
    Screen {
        background: $background;
        color: $text;
    }

    #sidebar {
        width: 25%;
        height: 100%;
        background: $surface;
    }

    #chat-area {
        width: 75%;
        height: 100%;
    }

    #chat-messages {
        height: 85%;
        width: 100%;
        overflow-y: auto;
    }

    #chat-input {
        height: 15%;
        width: 100%;
        dock: bottom;
        background: $surface;
        color: $text;
    }
    """

    selected_directory = reactive(Path)

    def __init__(self, directory: Path, query_engine: BaseQueryEngine, theme: str = "default"):
        super().__init__()
        self.selected_directory = directory
        self.query_engine = query_engine
        self.theme_name = theme

    def compose(self) -> ComposeResult:
        yield Header()
        with Horizontal():
            yield Container(DirectoryTree(str(self.selected_directory)), id="sidebar")
            with Container(id="chat-area"):
                yield RichLog(id="chat-messages", wrap=True)
                yield Input(placeholder="Type your message here...", id="chat-input")
        yield Footer()

    def on_mount(self) -> None:
        self.apply_theme()
        self.title = f"Dirtty - Chatting about {self.selected_directory.name}"
        self.query_one("#chat-input").focus()

    def apply_theme(self):
        theme_data = get_theme(self.theme_name)
        logger.debug(f"Applying theme: {theme_data}")
        colors = theme_data.get("colors", {})
        for color_name, color_value in colors.items():
            setattr(self.styles, color_name, color_value)
        self.dark = theme_data.get("dark", False)
        logger.info(f"Applied theme: {self.theme_name}")

    def on_input_submitted(self, event: Input.Submitted) -> None:
        input_widget = event.input
        message = input_widget.value
        self.query_one("#chat-messages", RichLog).write(f"You: {message}")

        try:
            response = self.query_engine.chat(message)
            self.query_one("#chat-messages", RichLog).write(f"Assistant: {str(response)}")
        except Exception as error:
            self.query_one("#chat-messages", RichLog).write(f"Error: {str(error)}", style="bold red")

        input_widget.value = ""
        self.query_one("#chat-messages").scroll_end(animate=False)


File: ./main.py
import logging
import sys
from pathlib import Path
from dirtty.cli import parse_args
from dirtty.helpers import setup_logging, clear_screen
from dirtty.app import DirttyApp
from llama_index.core import VectorStoreIndex, SimpleDirectoryReader, Settings
from llama_index.llms.ollama import Ollama
from llama_index.embeddings.huggingface import HuggingFaceEmbedding
from llama_index.core.memory import ChatMemoryBuffer
import multiprocessing

# Disable tqdm globally
from functools import partialmethod
from tqdm import tqdm
tqdm.__init__ = partialmethod(tqdm.__init__, disable=True)

logger = logging.getLogger(__name__)

def setup_index(documents, llm):
    logger.info("Setting up index")
    Settings.embed_model = HuggingFaceEmbedding(model_name="BAAI/bge-base-en-v1.5")
    Settings.llm = llm
    index = VectorStoreIndex.from_documents(documents, show_progress=False)
    logger.info("Index setup complete")
    return index

def load_documents(directory: Path):
    logger.info(f"Loading documents from {directory}")
    documents = SimpleDirectoryReader(input_dir=str(directory), recursive=True).load_data()
    logger.info(f"Loaded {len(documents)} documents")
    return documents

def setup_llm(model_name: str):
    logger.info(f"Setting up Ollama LLM with model: {model_name}")
    from ollama import Client
    client = Client()
    try:
        client.show(model_name)
    except Exception as error:
        logger.error(f"Model '{model_name}' not found. Error: {str(error)}")
        raise ValueError(f"Model '{model_name}' not found. Please pull it using 'ollama pull {model_name}' before running the application.")
    return Ollama(model=model_name, request_timeout=360.0)

def create_query_engine(index):
    logger.info("Creating query engine")
    memory = ChatMemoryBuffer.from_defaults(token_limit=300000)
    chat_engine = index.as_chat_engine(
        chat_mode="context",
        memory=memory,
        system_prompt="You are a chat bot able to have normal interactions and to provide coding support, as well as talk about the contents of a directory. Keep your responses concise and to the point.",
        max_iterations=10,
    )
    logger.info("Query engine created")
    return chat_engine

def main():
    # This is required on macOS to avoid issues with multiprocessing
    multiprocessing.set_start_method('spawn', force=True)

    opts = parse_args()
    setup_logging(opts['log_level'])
    logger.debug(f"Parsed options: {opts}")
    logger.info("Starting dirtty application")

    directory = Path(opts['args'].directory) if opts['args'].directory else None
    clear_screen()

    try:
        documents = load_documents(directory)
        llm = setup_llm(opts['model_name'])
        index = setup_index(documents, llm)
        query_engine = create_query_engine(index)

        logger.info("Starting TUI")
        app = DirttyApp(directory, query_engine, opts['theme'])
        app.run()
    except ValueError as error:
        logger.error(str(error))
        print(f"Error: {str(error)}")
        sys.exit(1)

if __name__ == "__main__":
    main()


File: ./helpers.py
import os
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

def setup_logging(log_level: str) -> None:
    if isinstance(log_level, int):
        log_level = logging.getLevelName(log_level)

    log_level = log_level.upper()
    numeric_level = getattr(logging, log_level, None)
    if not isinstance(numeric_level, int):
        raise ValueError(f'Invalid log level: {log_level}')

    log_dir = Path.home() / ".dirtty" / "logs"
    log_dir.mkdir(parents=True, exist_ok=True)
    log_file = log_dir / "dirtty.log"

    logging.basicConfig(
        filename=str(log_file),
        level=numeric_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    logger.info(f"Logging setup complete. Log level: {log_level}")
    logger.info(f"Log file location: {log_file}")

def ensure_directory(directory: str) -> Path:
    path = Path(directory)
    path.mkdir(parents=True, exist_ok=True)
    logger.info(f"Ensured directory exists: {path}")
    return path

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')


